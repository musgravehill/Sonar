<!doctype html>
<html lang="en">
    <head>
        <!-- Required meta tags -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-F3w7mX95PdgyTmZZMECAngseQB83DfGTowi0iMjiWaeVhAn4FJkqJByhZMI3AhiU" crossorigin="anonymous">
        <title>Sonar</title>
    </head>
    <body>
        <main class="container">

            <div id="map_palette"></div>
            <div id="map__bathymetry_block" style="width: 100%; height: 500px; margin: 4px 0px;"></div>


            <div id="map__logic_block" style="width: 100%; height:  300px; overflow: scroll;"></div>


            <textarea id="form_bathymetry__data_input" class="form-control d-inline-block" style="width: 300px; height: 100px;" placeholder="Bathymetry log"></textarea>
            <input type="number" id="form_bathymetry__depth_min_input" placeholder="min" value="0">
            <input type="number" id="form_bathymetry__depth_max_input" placeholder="max" value="5">
            <span id="form_bathymetry__btn_ok" class="btn btn-success">Ok</span>

            <textarea id="form_logic__data_input" class="form-control d-inline-block" style="width: 300px; height: 100px;" placeholder="Logic log"></textarea> 
            <span id="form_logic__btn_ok" class="btn btn-success">Ok</span>


            <script src="https://api-maps.yandex.ru/2.1/?lang=ru_RU&apikey=ea0860a1-d606-43c4-88f4-93529deb4edb" type="text/javascript"></script>
            <script>
                let map__map;
                let map__mapIsReady = false;
                let map__depth_min = 0;
                let map__depth_max = 0;
                const map__colors = [
                    '#f51c03',
                    '#f45202',
                    '#f38802',
                    '#f2be01',
                    '#f1f501',
                    '#bde708',
                    '#89da0f',
                    '#55cd16',
                    '#21c01d',
                    '#20ad31',
                    '#1f9a45',
                    '#1e8759',
                    '#1d746d',
                    '#1d6282',
                    '#1c4f96',
                    '#1b3caa',
                    '#1a29be',
                    '#1a17d3'
                ];


                document.addEventListener('DOMContentLoaded', function () {
                    ymaps.ready(map__init);
                });

                function map__render() {
                    map__palette();
                    map__actions();
                }

                function map__actions() {
                    $('#form_bathymetry__btn_ok').click(() => map__bathymetryProcess());
                    $('#form_logic__btn_ok').click(() => map__logicProcess());
                }

                function map__logicProcess() {
                    const lines = $('#form_logic__data_input').val().split(/\n/);
                    for (const line of lines) {
                        let lat = 0, lng = 0, RR = [], FF = [], offsetX = 0;
                        const raw = line.split(';');
                        //const lat = parseFloat(raw[0]) || 0;
                        //const lng = parseFloat(raw[1]) || 0;
                        for (var i = 1; i <= 16; i++) {
                            const mks = parseInt(raw[i]) || 0;
                            if (mks > 0) {
                                RR.push(mks);
                            }
                        }
                        for (var i = 18; i <= 33; i++) {
                            const mks = parseInt(raw[i]) || 0;
                            if (mks > 0) {
                                FF.push(mks);
                            }
                        }

                        for (const R of RR) {
                            let w = 0;
                            let start = Math.round((R - offsetX) / 10.0);
                            for (const F of FF) {
                                if (R <= F) {
                                    w = Math.round((F - R) / 10.0);
                                    offsetX = F;
                                    break;
                                }
                            }

                            $('#map__logic_block').append('<div class="logic_pulse" style="margin-left:' + start + 'px; width:' + w + 'px;"></div>');

                        }

                    }
                }

                function map__bathymetryProcess() {
                    map__depth_min = 0;
                    map__depth_max = 0;
                    let points = [];

                    const depth_min_allow = parseFloat($('#form_bathymetry__depth_min_input').val()) || 0;
                    const depth_max_allow = parseFloat($('#form_bathymetry__depth_max_input').val()) || 0;


                    const lines = $('#form_bathymetry__data_input').val().split(/\n/);
                    for (const line of lines) {
                        const raw = line.split(';');
                        const depthM = (parseInt(raw[2]) || 0) / 100.0;

                        if (depth_max_allow > 0 && (depthM < depth_min_allow || depthM > depth_max_allow)) {
                            continue; //this point bad, goto next point
                        }
                        const point = {
                            lat: parseFloat(raw[0]) || 0.0,
                            lng: parseFloat(raw[1]) || 0.0,
                            depth: depthM
                        };
                        points.push(point);
                        if (map__depth_min > point.depth) {
                            map__depth_min = point.depth;
                        }
                        if (map__depth_max < point.depth) {
                            map__depth_max = point.depth;
                        }
                    }

                    for (const point of points) {
                        if (point.lat > 0 && point.lng > 0) {
                            map__point(point.lat, point.lng, point.depth);
                        }
                    }

                }

                function map__palette() {
                    for (const color of map__colors) {
                        const dv = '<div class="palette__item d-inline-block" style="background-color:' + color + '"></div>';
                        $('#map_palette').append(dv);
                    }
                }

                const map_onReady_promise = new Promise((resolve, reject) => {
                    const timerId = setInterval(function () {
                        if (map__mapIsReady) {
                            clearInterval(timerId);
                            resolve();
                        }
                    }, 1000);
                });

                map_onReady_promise.then(map__render);

                function map__init() {
                    /* ymaps.geolocation.get().then(function (res) {
                     var mapContainer = $('#map__bathymetry_block'),
                     bounds = res.geoObjects.get(0).properties.get('boundedBy'),
                     // Рассчитываем видимую область для текущей положения пользователя.
                     mapState = ymaps.util.bounds.getCenterAndZoom(
                     bounds,
                     [mapContainer.width(), mapContainer.height()]
                     );
                     mapState.zoom = 11;
                     map__createMap(mapState);  
                     }, function (e) {
                     // Если местоположение невозможно получить, то просто создаем карту.
                     map__createMap({
                     center: [57, 39],
                     zoom: 11
                     });
                     });*/

                    map__createMap({
                        center: [57.647924, 39.980021],
                        zoom: 18
                    });
                }

                function map__createMap(state) {
                    map__map = new ymaps.Map('map__bathymetry_block', state);
                    map__mapIsReady = true;
                }



                function map__point(lat, lng, depthM) {
                    const color = map__getColor(depthM) + 'FF';
                    let r = 0.25;
                    let myCircle = new ymaps.Circle([
                        [lat, lng], // Координаты центра круга.            
                        r // Радиус круга в метрах.
                    ], {
                        balloonContent: Math.round(depthM * 100) / 100 + "m",
                        hintContent: Math.round(depthM * 100) / 100 + "m",
                    }, {
                        draggable: false,
                        fillColor: color, // Цвет заливки. Последний байт (77) определяет прозрачность.            
                        strokeColor: color, // Цвет обводки.            
                        strokeOpacity: 0, // Прозрачность обводки.           
                        strokeWidth: 1 // Ширина обводки в пикселях.
                    });
                    map__map.geoObjects.add(myCircle);
                }

                function map__getColor(depthM) {
                    const dx = (map__depth_max - map__depth_min) / map__colors.length;
                    let idx = Math.round(depthM / dx);
                    idx = Math.min(Math.max(parseInt(idx), 0), (map__colors.length - 1)); //constrain from to
                    return map__colors[idx];
                }

            </script>
        </main>
        <script
            src="https://code.jquery.com/jquery-3.6.0.min.js"
            integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4="
        crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-/bQdsTh/da6pkI1MST/rWKFNjaCP5gBSY4sEBT38Q/9RBh9AH40zEOg7Hlq2THRZ" crossorigin="anonymous"></script>
    </body>
</html>
<style>
    .palette__item {
        width:20px; 
        height:30px; 
        margin: 0;
        padding: 0;
    }
    .logic_pulse{
        height: 50px;
        background-color: #003580;
        display: inline-block;
    }
</style>
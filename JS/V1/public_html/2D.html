<!doctype html>
<html lang="en">
    <head>
        <!-- Required meta tags -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="bootstrap.min.css" rel="stylesheet">
        <title>3D bathymetry</title>
    </head>
    <body>
        <main class="container-fluid">
            <div class="row mt-2">
                <div class="col-2" style="height: 743px; overflow: scroll;">                    
                    <div class="d-block">
                        <b>
                            3D bathymetry 
                            <span id="bathymetry__points_count"></span>
                        </b>
                    </div> 
                    <div class="d-block mb-1"> 
                        <input type="number" id="form_bathymetry__depth_min_input" placeholder="Min depth, m" value="0.5" class="form-control d-inline-block form-control-sm" style="width: 90px">
                        <input type="number" id="form_bathymetry__depth_max_input" placeholder="Max depth, m" value="5" class="form-control d-inline-block form-control-sm" style="width: 90px">
                    </div>
                    <div class="d-block mb-1">                         
                        <input id="form_bathymetry__data_input_file" type="file" title="utf-8 txt" style="font-size: 10px;" />
                    </div>                    
                    <div class="d-block">
                        <span id="form_bathymetry__btn_ok" class="btn btn-success btn-sm">1. Ok</span>
                    </div>                     
                    <hr class="my-1">
                    <div class="d-block"> 
                        <b>Resolution of plane/section/3d</b><br>                        
                        dLat &nbsp;<input type="number" class="form-control d-inline-block form-control-sm" min="0.000001" value="0.00001" step="0.000001" id="sonar__resolution_dLat" style="width: 90px">        
                        <br>
                        dLng <input type="number" class="form-control d-inline-block form-control-sm" min="0.000001" value="0.000016" step="0.000001" id="sonar__resolution_dLng" style="width: 90px">   
                        <br>
                        Point, px <input type="number" class="form-control d-inline-block form-control-sm" min="1" value="6" step="1" id="sonar__resolution_point_px" style="width: 90px">   
                    </div>
                    <div class="d-block">
                        <input id="sonar__over_bottom" type="checkbox"> impulses over bottom  
                        <!--input id="sonar__full_bottom" type="checkbox" checked> bottom  &nbsp;&nbsp;&nbsp;-->
                    </div>
                    <div class="d-block">
                        <input id="sonar__plane_point_dot" type="checkbox"> bottom dots 
                    </div>
                    <hr class="my-1">
                    <div class="d-block">
                        <input id="sonar__map_is_allow" type="checkbox"> use map                          
                    </div>
                    <hr class="my-1">
                    <div class="d-block">  
                        <span id="sonar__real_ok" class="btn btn-sm btn-success mb-1">2. Real draw</span>                         
                    </div>
                    <hr class="my-1">
                    <div class="d-block"> 
                        Radius m                        
                        <input type="number" class="form-control d-inline-block form-control-sm" min="0.1" value="3" step="0.1" id="sonar__extrapolation_radius_m" style="width: 90px">        
                        <br>
                        Step lat &nbsp;                       
                        <input type="number" class="form-control d-inline-block form-control-sm" min="0.000001" value="0.00001" step="0.000001" id="sonar__extrapolation_lat_step" style="width: 90px">        
                        <br>
                        Step lng                      
                        <input type="number" class="form-control d-inline-block form-control-sm" min="0.000001" value="0.000016" step="0.000001" id="sonar__extrapolation_lng_step" style="width: 90px">        
                        <br>                      
                        <span id="sonar__extrapolation_ok" class="btn btn-sm btn-success">2. Extrapolation draw</span>                         
                    </div>
                    <hr class="my-1">
                    <div class="d-block">                         
                        3D point, px <input type="number" class="form-control d-inline-block form-control-sm" min="1" value="10" step="1" id="D3__resolution_point_px" style="width: 90px">   
                        <br>
                        <span class="btn btn-success" onclick="D3__init();">2.1. 3D draw</span>
                    </div>
                    <hr class="my-1">
                    <div class="d-block">
                        <b>Section</b><br>
                        ±lat &nbsp;<input type="number" class="form-control d-inline-block form-control-sm" min="0" value="0.00001" step="0.000001" id="sonar__section_dLat_limit" style="width: 90px">        
                        <br>
                        ±lng <input type="number" class="form-control d-inline-block form-control-sm" min="0" value="0.000030" step="0.000001" id="sonar__section_dLng_limit" style="width: 90px">   
                        <br>        
                        <input type="radio" name="sonar__section_isVertical" value="0" checked> --- &nbsp;&nbsp;
                        <input type="radio" name="sonar__section_isVertical" value="1"> | 
                        <br>
                        <span id="sonar__section_ok" class="btn btn-success btn-sm">3. Apply & begin</span> 
                        <br>        
                        <input type="checkbox" id="sonar__section_dotBottomDepth_isShow" value="1" checked> show bottom depth dots 
                    </div>                     
                    <hr class="my-1">
                    <div class="d-block">
                        <b>Reflection power</b><br>
                        <input type="range" class="form-range" min="0" max="15000" value="0" id="sonar__range_pulse_w_min_show"> 
                        hide weak < <span id="sonar__range_pulse_w_min_show_val"></span>
                        <div class="d-block">
                            <b>Palette</b><br>
                            <div class="d-block">
                                <input name="sonar__palette_power_idx" type="radio" checked value="1"> Sepia &nbsp;
                                <input name="sonar__palette_power_idx" type="radio" value="2"> BW &nbsp;
                                <input name="sonar__palette_power_idx" type="radio" value="3"> RGB 
                            </div>
                            <input type="range" class="form-range" min="0" max="15000" value="2000" id="sonar__range_pulse_w_max"> 
                        </div>
                        <div class="d-block align-middle"> 
                            <span id="sonar__range_pulse_w_min_val">0mks</span> 
                            <div class="d-inline-block align-middle">
                                <div class="d-block"><div id="sonar__palette_power_sepia"></div></div>
                                <div class="d-block"><div id="sonar__palette_power_bw"></div></div>
                                <div class="d-block"><div id="sonar__palette_power_rgb"></div></div>       
                            </div>
                            <span id="sonar__range_pulse_w_max_val"></span>
                        </div>       
                    </div>                    
                    <hr class="my-1">
                    <div class="d-block" style="font-size: 12px;">
                        <b>Min-Max</b><br>
                        Ш.(lat) min=<span id="sonar__info_latMin"></span>       
                        <br>
                        Ш.(lat) max=<span id="sonar__info_latMax"></span>       
                        <br>
                        Д.(lng) min=<span id="sonar__info_lngMin"></span>       
                        <br>
                        Д.(lng) max=<span id="sonar__info_lngMax"></span>       
                        <br>
                    </div>
                    <hr class="my-1">
                    <div class="d-block" style="font-size: 12px;">
                        <b>Точки</b>  
                        Клик: рисует сечение толщи воды в окрестности точки. Наведение: инфо про точку.
                        <br>
                        <b>В толще воды</b> 
                        Наведение на точку или импульс: покажет отражения в толще воды, глубину, начало отражения ото дна pulseRising мкс, ширину пульса pulseWidth мкс.       
                    </div> 
                </div> 
                <div class="col-10">       
                    <div class="row">
                        <div class="col-auto">
                            <div id="sonar__section_block"></div> 
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-auto">
                            <div class="d-block mt-1">
                                <b>Depth</b>          
                                <div id="sonar__palette_depth_min_text" class="d-inline-block" style="width: 50px;"></div> 
                                <div class="d-inline-block"><div id="sonar__palette_depth"></div></div> 
                                <div id="sonar__palette_depth_max_text" class="d-inline-block"></div>
                                <b>Point</b> <span id="sonar__point_selected_latlng" style="font-size: 13px;"></span>
                            </div>
                            <div id="sonar__plane_block"></div>
                        </div>
                        <div class="col-auto">
                            <div id="map__bathymetry_block"></div>
                        </div>
                        <div class="col-12">
                            <canvas id="D3__canvas_heightmap" style="border:1px solid black;"></canvas>
                            <canvas id="D3__canvas_texture" style="border:1px solid black;"></canvas>
                            <span id="D3__controls_x_dec" class="btn" D3__controls >X-</span>
                            <span id="D3__controls_x_inc" class="btn" D3__controls >X+</span>
                            <span id="D3__controls_y_dec" class="btn" D3__controls >Y-</span>
                            <span id="D3__controls_y_inc" class="btn" D3__controls >Y+</span>
                            <span id="D3__controls_z_dec" class="btn" D3__controls >Z-</span>
                            <span id="D3__controls_z_inc" class="btn" D3__controls >Z+</span>
                            <span id="D3__controls_cam_dec" class="btn" D3__controls >cam-</span>
                            <span id="D3__controls_cam_inc" class="btn" D3__controls >cam+</span> 
                            <div id="D3__container"></div>
                        </div>
                    </div>                       
                </div>                
            </div> 
        </main>



    </body>
</html>

<script src="jquery-3.6.0.min.js"></script>
<script src="bootstrap.bundle.min.js"></script>
<script src="https://api-maps.yandex.ru/2.1/?lang=ru_RU&apikey=ea0860a1-d606-43c4-88f4-93529deb4edb" type="text/javascript"></script>

<script src="three.js"></script>
<script src="OrbitControls.js"></script> 

<script>
                            const sonar__waiting_html = '<span sonar__waiting_html class="spinner-border text-danger spinner-border-sm" role="status"></span>';

                            let sonar__real_pointsLatLng = [];
                            let sonar__plane_pointsLatLng = [];
                            let sonar__map_pointsLatLng = [];
                            let sonar__section_pointsLatLng = [];
                            let D3__pointsLatLng = [];
                            //                
                            let sonar__section_pointsLatLng_used = [];
                            let sonar__section_isVertical = false;
                            let sonar__section_dLat_limit = 0;
                            let sonar__section_dLng_limit = 0;
                            //
                            let sonar__depth_min_m = 999;
                            let sonar__depth_max_m = 0;
                            let sonar__depth_max_latlng = [0, 0];
                            let sonar__depth_min_limit = 0;
                            let sonar__depth_max_limit = 0;
                            let sonar__dataItemsCount = 0;
                            const sonar__colors_depth = [
                                '#ff3c00', '#fe4900', '#fe5600', '#fe6300', '#fd7000', '#fd7d00', '#fd8a00', '#fd9700', '#fca400', '#fcb100', '#fcbe00', '#fccb00', '#fbd800', '#fbe500', '#fbf200', '#fbff00',
                                '#76ff00', '#6ef402', '#66ea04', '#5ee006', '#56d609', '#4ecc0b', '#46c20d', '#3eb80f', '#37ae12', '#2fa414', '#279a16', '#1f9018', '#17861b', '#0f7c1d', '#07721f', '#006822',
                                '#3debff', '#3cdef7', '#3bd1ef', '#3ac4e8', '#39b7e0', '#39abd9', '#389ed1', '#3791ca', '#3684c2', '#3577bb', '#356bb3', '#345eac', '#3351a4', '#32449d', '#313795', '#312b8e'
                            ];
                            let sonar__lat_min = 999, sonar__lng_min = 999, sonar__lat_max = 0, sonar__lng_max = 0;
                            let sonar__getColor_depth_m_dx = 1;
                            let sonar__mks2px_fullScale_dx = 1;
                            let sonar__pulses_block_h_px = 200;
                            const sonar__mks2px_fullScale_multiplier_vertical = 2.0; //draw on block height = x * sonar__depth_max_limit 
                            const sonar__pulse_underBottom_compression_vertical = 5.0; //compress pulses under bottom
                            const sonar__plane_compression_vertical = 5.0; //compress pulses block
                            const sonar__mks2m = 1367.0;
                            let sonar__resolution_dLat = 0;
                            let sonar__resolution_dLng = 0;
                            let sonar__resolution_point_px = 0; //px; 
                            let sonar__pulse_size_offset_coef_lat = 0;
                            let sonar__pulse_size_offset_coef_lng = 0;

                            const sonar__palette_power_rgb = [
                                '#0011fa',
                                '#016efa',
                                '#03cbfa',
                                '#009716',
                                '#45c80c',
                                '#8afa03',
                                '#fa8803',
                                '#fa4503',
                                '#fa0303'
                            ]; //9                    
                            const sonar__palette_power_bw = [
                                '#f0f1f5',
                                '#d2d3d7',
                                '#b5b6b9',
                                '#97989b',
                                '#7a7b7d',
                                '#5d5d5f',
                                '#3f4041',
                                '#222223',
                                '#050505'
                            ]; //9  
                            const sonar__palette_power_sepia = [
                                '#f1d98f', '#ddc57d', '#c9b26b', '#b69f59', '#a28c47', '#8e7835', '#7b6523', '#675211', '#543f00'
                            ]; //9  

                            let sonar__colors_power_dx = (2000 - 0) / sonar__palette_power_rgb.length; //default, change by input-range
                            let sonar__palette_power_idx = 1;
                            //    
                            let sonar__extrapolation_pointsLatLng = [];
                            let sonar__extrapolation_lat_step = 0;
                            let sonar__extrapolation_lng_step = 0;
                            let sonar__extrapolation_radius_m = 0;

                            document.addEventListener('DOMContentLoaded', function () {
                                sonar__palettes();
                                sonar__actions();
                            });

                            function sonar__actions() {
                                $('#sonar__section_block').css('height', parseInt(50 + sonar__pulses_block_h_px) + 'px');

                                $('#form_bathymetry__btn_ok').click(() => {
                                    //$('#form_bathymetry__btn_ok').hide().after(sonar__waiting_html);
                                    sonar__bathymetryProcessInit();
                                    //$('#form_bathymetry__btn_ok').show();
                                    //$('span[sonar__waiting_html]').remove();
                                });
                                $('#sonar__real_ok').click(() => {
                                    //$('#sonar__real_ok').hide().after(sonar__waiting_html);
                                    sonar__real_process();
                                    //$('#sonar__real_ok').show();
                                    //$('span[sonar__waiting_html]').remove();
                                });
                                $('#sonar__extrapolation_ok').click(() => {
                                    //$('#sonar__extrapolation_ok').after(sonar__waiting_html).hide();
                                    sonar__extrapolation_process();
                                    //$('#sonar__extrapolation_ok').show();
                                    //$('span[sonar__waiting_html]').remove();
                                });
                                $('#sonar__section_ok').click(() => {
                                    sonar__section_init();
                                });

                                $('#sonar__resolution_dLat').change(() => {
                                    sonar__resolution_calc();
                                    sonar__axisDraw();
                                });
                                $('#sonar__resolution_dLng').change(() => {
                                    sonar__resolution_calc();
                                    sonar__axisDraw();
                                });
                                $('#sonar__resolution_point_px').change(() => {
                                    sonar__resolution_calc();
                                    sonar__axisDraw();
                                });



                                $('#sonar__over_bottom').change(() => {
                                    if ($('#sonar__over_bottom').is(":checked")) {
                                        $('div.sonar__plane_point_pulses').show();
                                    } else {
                                        $('div.sonar__plane_point_pulses').hide();
                                    }
                                });
                                $('#sonar__plane_point_dot').change(() => {
                                    if ($('#sonar__plane_point_dot').is(":checked")) {
                                        $('div.sonar__plane_point_dot').show();
                                    } else {
                                        $('div.sonar__plane_point_dot').hide();
                                    }
                                });
                                $('#sonar__range_pulse_w_min_show').change(() => {
                                    sonar__pulses_hideWeak();
                                });
                                $('input[name=sonar__palette_power_idx]').change(() => {
                                    sonar__palette_power_idx = parseInt($('input[name=sonar__palette_power_idx]:checked').val());
                                    sonar__pulses_setColor();
                                });
                                $('#sonar__range_pulse_w_max').change(() => {
                                    const pulseW_mks = parseInt($('#sonar__range_pulse_w_max').val()) || 0;
                                    sonar__colors_power_dx = (pulseW_mks - 0) / sonar__palette_power_rgb.length;
                                    $('#sonar__range_pulse_w_max_val').html(pulseW_mks + 'mks');
                                    sonar__pulses_setColor();
                                });
                                $('#sonar__map_is_allow').change(() => {
                                    map__create();
                                });

                                $('#sonar__section_dotBottomDepth_isShow').change(() => {
                                    if ($('#sonar__section_dotBottomDepth_isShow').is(":checked")) {
                                        $('div.sonar__section_dotBottomDepth').show();
                                    } else {
                                        $('div.sonar__section_dotBottomDepth').hide();
                                    }
                                });

                            }
                            function sonar__point_selected_latlng() {
                                $('[sonar__point_selected_latlng][todo]').click(function () {
                                    const el = $(this);
                                    el.removeAttr('todo');
                                    $('#sonar__point_selected_latlng').html(el.attr('title'));
                                });
                            }
//==================================== START ===============================================================================================================================
                            function sonar__real_process() {
                                sonar__plane_pointsLatLng = [];
                                sonar__map_pointsLatLng = [];
                                sonar__section_pointsLatLng = [];
                                sonar__extrapolation_pointsLatLng = [];
                                sonar__section_pointsLatLng_used = [];

                                sonar__resolution_calc();

                                sonar__plane_points_init(sonar__real_pointsLatLng);
                                sonar__plane_points_draw();

                                sonar__map_points_init(sonar__real_pointsLatLng);
                                sonar__map_points_draw();

                                sonar__section_points_init(sonar__real_pointsLatLng);
                                sonar__section_init();

                                sonar__point_selected_latlng();
                                sonar__axisDraw();

                                D3__pointsLatLng = sonar__real_pointsLatLng;
                            }
                            function sonar__extrapolation_process() {
                                sonar__plane_pointsLatLng = [];
                                sonar__map_pointsLatLng = [];
                                sonar__section_pointsLatLng = [];
                                sonar__extrapolation_pointsLatLng = [];
                                sonar__section_pointsLatLng_used = [];

                                sonar__resolution_calc();

                                sonar__extrapolation_init();

                                sonar__plane_points_init(sonar__extrapolation_pointsLatLng);
                                sonar__plane_points_draw();

                                sonar__map_points_init(sonar__extrapolation_pointsLatLng);
                                sonar__map_points_draw();

                                sonar__section_points_init(sonar__extrapolation_pointsLatLng);
                                sonar__section_init();

                                sonar__point_selected_latlng();
                                sonar__axisDraw();

                                D3__pointsLatLng = sonar__extrapolation_pointsLatLng;
                            }
//==================================== SECTION ===============================================================================================================================
                            function sonar__section_points_init(pointsLatLng) {
                                sonar__section_pointsLatLng = pointsLatLng;
                            }
                            function sonar__section_init() {
                                $('#sonar__section_block').html('');
                                sonar__section_pointsLatLng_used = [];
                                sonar__section_isVertical = parseInt($('input[name="sonar__section_isVertical"]:checked').val()) === 1 ? true : false;
                                sonar__section_dLat_limit = parseFloat($('#sonar__section_dLat_limit').val()) || 0;
                                sonar__section_dLng_limit = parseFloat($('#sonar__section_dLng_limit').val()) || 0;
                                $('div.sonar__section_area').remove();
                                sonar__map_points_draw();//clean red-rect radius                     

                                $('div.sonar__plane_point_dot').unbind('click').click(function () {
                                    const lat = parseFloat($(this).attr('lat')) || 0;
                                    const lng = parseFloat($(this).attr('lng')) || 0;
                                    sonar__section_pointsInArea_process(lat, lng); //точку, в окрестности которой будем искать                       
                                });
                            }
                            function sonar__section_area_draw(lat, lng) {
                                if (lat < 1 || lng < 1) {
                                    return;
                                }
                                //draw red RECT +_ dlat dlong                      
                                const h_px = parseInt((2 * sonar__section_dLat_limit) / sonar__pulse_size_offset_coef_lat);
                                const w_px = parseInt((2 * sonar__section_dLng_limit) / sonar__pulse_size_offset_coef_lng);
                                const top_px = parseInt((sonar__pulses_block_h_px / sonar__plane_compression_vertical) + sonar__getOffsetLat_px(lat) - 0.5 * h_px + 0.5 * sonar__resolution_point_px);
                                const left_px = parseInt(sonar__getOffsetLng_px(lng) - 0.5 * w_px + 0.5 * sonar__resolution_point_px);
                                let html = '<div class="sonar__section_area" style="left:' + left_px + 'px; top:' + top_px + 'px; width:' + w_px + 'px; height:1px; ">';
                                html += '</div>';
                                html += '<div class="sonar__section_area" style="left:' + left_px + 'px; top:' + parseInt(top_px + h_px) + 'px; width:' + w_px + 'px; height:1px; ">';
                                html += '</div>';
                                html += '<div class="sonar__section_area" style="left:' + left_px + 'px; top:' + top_px + 'px; width:1px; height:' + h_px + 'px; ">';
                                html += '</div>';
                                html += '<div class="sonar__section_area" style="left:' + parseInt(left_px + w_px) + 'px; top:' + top_px + 'px; width:1px; height:' + h_px + 'px; ">';
                                html += '</div>';
                                $('#sonar__plane_block').append(html);
                            }
                            function sonar__section_pointsInArea_process(lat, lng) {
                                if (lat < 1 || lng < 1) {
                                    return;
                                }

                                sonar__section_area_draw(lat, lng);
                                sonar__map_section_area(lat, lng);

                                for (let index in sonar__section_pointsLatLng) {
                                    const ll = index.split(/_/);
                                    let lat_curr = parseFloat(ll[0]) || 0;
                                    let lng_curr = parseFloat(ll[1]) || 0;
                                    lat_curr = Math.round(lat_curr * 1000000) / 1000000;//6
                                    lng_curr = Math.round(lng_curr * 1000000) / 1000000;//6

                                    const dLat = Math.abs(lat_curr - lat);
                                    const dLng = Math.abs(lng_curr - lng);

                                    const idx = lat_curr + '_' + lng_curr;
                                    if (sonar__section_pointsLatLng_used.hasOwnProperty(idx)) {
                                        continue;//dont draw this point -> it already drawn 
                                    }

                                    if (dLat <= sonar__section_dLat_limit && dLng <= sonar__section_dLng_limit) {
                                        $('#sonar__section_block').append(sonar__section_point(lat_curr, lng_curr, sonar__section_pointsLatLng[index]));
                                        sonar__section_pointsLatLng_used[idx] = 1;
                                    }
                                }
                                sonar__section_applyMenuParams();
                                sonar__pulses_hideWeak();
                                sonar__point_selected_latlng();
                            }
                            function sonar__section_point(lat, lng, data) {
                                if (lat < 1 || lng < 1) {
                                    return;
                                }
                                const depth_color = sonar__getColor_depth_m(data.depthM);
                                const left_px = Math.round(sonar__section_isVertical ? sonar__getOffsetLat_px(lat) : sonar__getOffsetLng_px(lng));
                                let mt_px = Math.round(6 + sonar__mks2px_fullScale(data.depth_mks));

                                let html = '<div class="sonar__section_dotBottomDepth" title="' + (Math.round(data.depthM * 100) / 100) + 'm ' + lat + ' ' + lng + ' " style="left:' + left_px + 'px; top:' + mt_px + 'px; background-color:' + depth_color + '; width:' + sonar__resolution_point_px + 'px; height: ' + sonar__resolution_point_px + 'px; "></div>';
                                for (const pulse of data.pulses) {
                                    if (pulse.R <= (data.depth_mks + 150)) {
                                        mt_px = sonar__mks2px_fullScale(pulse.R); //fish over bottom                           
                                    } else {
                                        mt_px = sonar__mks2px_fullScale((pulse.R / sonar__pulse_underBottom_compression_vertical) + data.depth_mks); //under bottom  уплотняем картинку в Х раз 
                                    }
                                    const pulse_color = sonar__getColor_power_mks(pulse.W);
                                    html += '<div class="sonar__section_pulse" title="' + (Math.round((pulse.R / sonar__mks2m) * 100) / 100) + 'm ' + lat + ' ' + lng + '  R=' + pulse.R + ' W=' + pulse.W + '" w_mks="' + pulse.W + '" style="left:' + left_px + 'px; top:' + mt_px + 'px; width:' + sonar__resolution_point_px + 'px;  height: ' + sonar__resolution_point_px + 'px; background-color:' + pulse_color + '; z-index:' + pulse.W + '; "></div>';
                                }

                                html += '<div class="sonar__section_dotBottomDepth_line" sonar__point_selected_latlng todo title="' + (Math.round(data.depthM * 100) / 100) + 'm ' + lat + ' ' + lng + ' " style="left:' + left_px + 'px; top:' + (6 + sonar__pulses_block_h_px) + 'px; background-color:' + depth_color + '; width:' + sonar__resolution_point_px + 'px;  "></div>';

                                return html;
                            }
                            function sonar__section_applyMenuParams() {
                                if ($('#sonar__section_dotBottomDepth_isShow').is(":checked")) {
                                    $('div.sonar__section_dotBottomDepth').show();
                                } else {
                                    $('div.sonar__section_dotBottomDepth').hide();
                                }
                            }
//==================================== PLANE  =============================================================================================================================== 
                            function sonar__plane_points_init(pointsLatLng) {
                                sonar__plane_pointsLatLng = pointsLatLng;
                            }
                            function sonar__plane_points_draw() {
                                $('#sonar__plane_block').html('');

                                is_sonar__over_bottom = $('#sonar__over_bottom').is(":checked");
                                is_sonar__plane_point_dot = $('#sonar__plane_point_dot').is(":checked");

                                if (is_sonar__over_bottom || is_sonar__plane_point_dot) {
                                    for (let index in  sonar__plane_pointsLatLng) {
                                        const ll = index.split(/_/);
                                        const lat_curr = parseFloat(ll[0]) || 0;
                                        const lng_curr = parseFloat(ll[1]) || 0;
                                        sonar__plane_point(lat_curr, lng_curr, sonar__plane_pointsLatLng[index], is_sonar__over_bottom, is_sonar__plane_point_dot);
                                    }
                                    sonar__point_selected_latlng();
                                }
                            }
                            function sonar__plane_point(lat, lng, data, is_sonar__over_bottom, is_sonar__plane_point_dot) {
                                if (lat < 1 || lng < 1) {
                                    return;
                                }
                                const depth_color = sonar__getColor_depth_m(data.depthM);
                                const left_px = sonar__getOffsetLng_px(lng);
                                const top_px = sonar__getOffsetLat_px(lat);
                                let html = '';
                                if (is_sonar__over_bottom) {
                                    html += '<div title="' + (Math.round((data.depthM) * 100) / 100) + 'm ' + lat + ' ' + lng + ' " class="sonar__plane_point_pulses" style="left:' + left_px + 'px; top:' + top_px + 'px; width:' + sonar__resolution_point_px + 'px; height: ' + Math.round(sonar__pulses_block_h_px / sonar__plane_compression_vertical) + 'px; ">'; //border-bottom: ' + sonar__resolution_point_px + 'px solid ' + depth_color + ';
                                    for (const pulse of data.pulses) {
                                        if (pulse.R <= (data.depth_mks + 150)) {
                                            //fish over bottom                           
                                        } else {
                                            continue; //under bottom
                                        }
                                        const pulse_color = sonar__getColor_power_mks(pulse.W); //fish over bottom                         
                                        const mt_px = Math.round(sonar__mks2px_fullScale(pulse.R) / sonar__plane_compression_vertical);
                                        html += '<div class="sonar__plane_point_pulse" title="' + (Math.round((pulse.R / sonar__mks2m) * 100) / 100) + 'm ' + lat + ' ' + lng + '  R=' + pulse.R + ' W=' + pulse.W + '" w_mks="' + pulse.W + '" style="top:' + mt_px + 'px; width:' + (sonar__resolution_point_px - 2) + 'px; background-color:' + pulse_color + '; "></div>';
                                    }
                                    html += '</div>';
                                }
                                if (is_sonar__plane_point_dot) {
                                    html += '<div class="sonar__plane_point_dot" sonar__point_selected_latlng todo lat="' + lat + '" lng="' + lng + '" title="' + (Math.round(data.depthM * 100) / 100) + 'm ' + lat + ' ' + lng + ' " style="left:' + left_px + 'px; top:' + Math.round((sonar__pulses_block_h_px / sonar__plane_compression_vertical) + top_px) + 'px; background-color:' + depth_color + '; width:' + sonar__resolution_point_px + 'px; height:' + sonar__resolution_point_px + 'px; ">';
                                    html += '</div>';
                                }

                                $('#sonar__plane_block').append(html);
                            }
//==================================== EXTRAPOLATION ===============================================================================================================================
                            function sonar__extrapolation_init() {
                                sonar__extrapolation_pointsLatLng = [];

                                sonar__extrapolation_lat_step = parseFloat($('#sonar__extrapolation_lat_step').val()) || 0;
                                sonar__extrapolation_lng_step = parseFloat($('#sonar__extrapolation_lng_step').val()) || 0;
                                sonar__extrapolation_radius_m = parseFloat($('#sonar__extrapolation_radius_m').val()) || 0;

                                let lat_curr = sonar__lat_min;
                                while (lat_curr < sonar__lat_max) {
                                    let lng_curr = sonar__lng_min;
                                    while (lng_curr < sonar__lng_max) {
                                        lat_curr = Math.round(lat_curr * 1000000) / 1000000;//6
                                        lng_curr = Math.round(lng_curr * 1000000) / 1000000;//6
                                        sonar__extrapolation_point_calc(lat_curr, lng_curr);
                                        lng_curr += sonar__extrapolation_lng_step;
                                    }
                                    lat_curr += sonar__extrapolation_lat_step;
                                }
                            }
                            function sonar__extrapolation_point_calc(lat, lng) {
                                const idx = lat + '_' + lng;

                                //is isset real point => return it, dont re-calc
                                if (sonar__real_pointsLatLng.hasOwnProperty(idx)) {
                                    const point = {
                                        depthM: sonar__real_pointsLatLng[idx].depthM,
                                        depth_mks: (sonar__real_pointsLatLng[idx].depthM * sonar__mks2m),
                                        pulses: []
                                    };
                                    sonar__extrapolation_pointsLatLng[idx] = point;
                                    return;
                                }

                                let depthsWeightingFactors = [];
                                for (let index in sonar__real_pointsLatLng) {
                                    const ll = index.split(/_/);
                                    const lat_curr = parseFloat(ll[0]) || 0;
                                    const lng_curr = parseFloat(ll[1]) || 0;
                                    const distance_m = sonar__distanceTwoPoints_m(lat, lng, lat_curr, lng_curr);
                                    if (distance_m <= sonar__extrapolation_radius_m) {
                                        const idxDWF = Math.round(1000 / distance_m);
                                        depthsWeightingFactors[idxDWF] = sonar__real_pointsLatLng[index].depthM;
                                    }
                                }
                                if (depthsWeightingFactors.length) {
                                    let depthM = 0;
                                    let idxDWF_sum = 0;
                                    for (let idxDWF in depthsWeightingFactors) {
                                        idxDWF_sum += parseInt(idxDWF);
                                    }
                                    for (let idxDWF in depthsWeightingFactors) {
                                        depthM += depthsWeightingFactors[idxDWF] * idxDWF / idxDWF_sum;
                                    }
                                    if (depthM > 0.1) {
                                        const point = {
                                            depthM: depthM,
                                            depth_mks: (depthM * sonar__mks2m),
                                            pulses: []
                                        };
                                        sonar__extrapolation_pointsLatLng[idx] = point;
                                    }
                                }

                                return;
                            }
//==================================== MAP =============================================================================================================================== 
                            function map__create() {
                                if (!$('#sonar__map_is_allow').is(":checked")) {
                                    $('#map__bathymetry_block').html('');
                                    sonar__map_pointsLatLng = [];
                                    return;
                                }
                                if (typeof ymaps !== 'undefined') {
                                    ymaps.ready(map__init);
                                }
                            }

                            let map__map;
                            let map__mapIsReady = false;
                            /*document.addEventListener('DOMContentLoaded', function () {
                             if (typeof ymaps !== 'undefined') {
                             ymaps.ready(map__init);
                             }
                             });*/
                            function map__init() {
                                $('#map__bathymetry_block').html('');
                                ymaps.geolocation.get().then(function (res) {
                                    var mapContainer = $('#map__bathymetry_block'),
                                            bounds = res.geoObjects.get(0).properties.get('boundedBy'),
                                            // Рассчитываем видимую область для текущей положения пользователя.
                                            mapState = ymaps.util.bounds.getCenterAndZoom(
                                                    bounds,
                                                    [mapContainer.width(), mapContainer.height()]
                                                    );
                                    mapState.zoom = 11;
                                    map__createMap(mapState);
                                }, function (e) {
                                    // Если местоположение невозможно получить, то просто создаем карту.
                                    map__createMap({
                                        center: [57, 39],
                                        zoom: 11
                                    });
                                });
                            }
                            function map__createMap(state) {
                                if (typeof ymaps !== 'undefined') {
                                    map__map = new ymaps.Map('map__bathymetry_block', state);
                                    map__mapIsReady = true;
                                }
                            }
                            function sonar__map_points_init(pointsLatLng) {
                                if (!map__mapIsReady) {
                                    return;
                                }
                                if (!$('#sonar__map_is_allow').is(":checked")) {
                                    return;
                                }
                                sonar__map_pointsLatLng = [];
                                for (let index in pointsLatLng) {
                                    const ll = index.split(/_/);
                                    const lat = parseFloat(ll[0]) || 0;
                                    const lng = parseFloat(ll[1]) || 0;
                                    const lat5 = Math.round(lat * 100000) / 100000;//5
                                    const lng5 = Math.round(lng * 100000) / 100000;//5
                                    const idx5 = lat5 + '_' + lng5;
                                    const point5 = {
                                        depthM: pointsLatLng[index].depthM,
                                        depth_mks: pointsLatLng[index].depth_mks,
                                        pulses: []
                                    };
                                    sonar__map_pointsLatLng[idx5] = point5;
                                }
                            }
                            function sonar__map_points_draw() {
                                if (!map__mapIsReady) {
                                    return;
                                }
                                if (!$('#sonar__map_is_allow').is(":checked")) {
                                    return;
                                }
                                map__map.geoObjects.removeAll();
                                for (let index in sonar__map_pointsLatLng) {
                                    const ll = index.split(/_/);
                                    const lat_curr = parseFloat(ll[0]) || 0;
                                    const lng_curr = parseFloat(ll[1]) || 0;
                                    sonar__map_point(lat_curr, lng_curr, sonar__map_pointsLatLng[index].depthM);
                                }
                            }
                            function sonar__map_point(lat, lng, depthM) {
                                if (lat < 1 || lng < 1) {
                                    return;
                                }
                                const color = sonar__getColor_depth_m(depthM) + 'FF';
                                const r = 1;
                                const myCircle = new ymaps.Circle([
                                    [lat, lng], // Координаты центра круга.            
                                    r // Радиус круга в метрах.
                                ], {
                                    balloonContent: Math.round(depthM * 100) / 100 + "m",
                                    hintContent: Math.round(depthM * 100) / 100 + "m",
                                }, {
                                    draggable: false,
                                    fillColor: color, // Цвет заливки. Последний байт (77) определяет прозрачность.            
                                    strokeColor: color, // Цвет обводки.            
                                    strokeOpacity: 0, // Прозрачность обводки.           
                                    strokeWidth: 1 // Ширина обводки в пикселях.
                                });
                                map__map.geoObjects.add(myCircle);
                            }
                            function sonar__map_section_area(lat, lng) {
                                if (!map__mapIsReady) {
                                    return;
                                }
                                if (!$('#sonar__map_is_allow').is(":checked")) {
                                    return;
                                }
                                if (lat < 1 || lng < 1) {
                                    return;
                                }
                                const myRectangle = new ymaps.Rectangle([
                                    // Задаем координаты диагональных углов прямоугольника.
                                    [(lat + sonar__section_dLat_limit), (lng - sonar__section_dLng_limit)],
                                    [(lat - sonar__section_dLat_limit), (lng + sonar__section_dLng_limit)]
                                ], {
                                    //Свойства
                                    hintContent: '',
                                    balloonContent: ''
                                }, {
                                    // Опции.
                                    // Цвет и прозрачность заливки.
                                    fillColor: '#00000000',
                                    // Дополнительная прозрачность заливки..
                                    // Итоговая прозрачность будет не #33(0.2), а 0.1(0.2*0.5).
                                    fillOpacity: 0.5,
                                    // Цвет обводки.
                                    strokeColor: '#FF0000',
                                    // Прозрачность обводки.
                                    strokeOpacity: 0.8,
                                    // Ширина линии.
                                    strokeWidth: 1,
                                    // Радиус скругления углов.
                                    // Данная опция принимается только прямоугольником.
                                    borderRadius: 0
                                });
                                map__map.geoObjects.add(myRectangle);
                            }

//==================================== SYS ===============================================================================================================================
                            function sonar__getColor_depth_m(m) {
                                let idx = Math.round(parseFloat(m - sonar__depth_min_m) / sonar__getColor_depth_m_dx);
                                idx = Math.min(Math.max(idx, 0), (sonar__colors_depth.length - 1)); //constrain from to  
                                return sonar__colors_depth[idx];
                            }
                            function sonar__getColor_power_mks(mks) {
                                let idx = Math.round(mks / sonar__colors_power_dx);
                                idx = Math.min(Math.max(parseInt(idx), 0), (sonar__palette_power_rgb.length - 1)); //constrain from to
                                switch (sonar__palette_power_idx) {
                                    case 1:
                                        return  sonar__palette_power_sepia[idx];
                                    case 2:
                                        return  sonar__palette_power_bw[idx];
                                    case 3:
                                        return  sonar__palette_power_rgb[idx];
                                }
                                return  sonar__palette_power_bw[idx];
                            }
                            /*function sonar__mks2px(mks, point_depth_mks) {
                             const sonar__mks2px_dx = point_depth_mks / sonar__pulses_block_h_px;
                             let px = Math.round(mks / sonar__mks2px_dx);
                             px = Math.min(Math.max(px, 0), sonar__pulses_block_h_px); //constrain from to
                             return px;
                             }*/
                            function sonar__mks2px_fullScale(mks) {
                                let px = Math.round(mks / sonar__mks2px_fullScale_dx);
                                px = Math.min(Math.max(px, 0), sonar__pulses_block_h_px); //constrain from to
                                return px;
                            }

                            function sonar__getOffsetLat_px(lat) {
                                let px = Math.round((sonar__lat_max - lat) / sonar__pulse_size_offset_coef_lat);
                                return px;

                            }
                            function sonar__getOffsetLng_px(lng) {
                                let px = Math.round((lng - sonar__lng_min) / sonar__pulse_size_offset_coef_lng);
                                return px;
                            }

                            function sonar__palettes() {
                                for (const color of sonar__colors_depth) {
                                    const dv = '<div class="palette__item d-inline-block" style="background-color:' + color + '"></div>';
                                    $('#sonar__palette_depth').append(dv);
                                }
                                for (const color of sonar__palette_power_rgb) {
                                    const dv = '<div class="palette__item d-inline-block" style="background-color:' + color + '"></div>';
                                    $('#sonar__palette_power_rgb').append(dv);
                                }
                                for (const color of sonar__palette_power_bw) {
                                    const dv = '<div class="palette__item d-inline-block" style="background-color:' + color + '"></div>';
                                    $('#sonar__palette_power_bw').append(dv);
                                }
                                for (const color of sonar__palette_power_sepia) {
                                    const dv = '<div class="palette__item d-inline-block" style="background-color:' + color + '"></div>';
                                    $('#sonar__palette_power_sepia').append(dv);
                                }
                            }

                            function sonar__bathymetryProcessInit() {
                                sonar__real_pointsLatLng = [];
                                sonar__depth_min_m = 999;
                                sonar__depth_max_m = 0;
                                sonar__depth_min_limit = parseFloat($('#form_bathymetry__depth_min_input').val()) || 0;
                                sonar__depth_max_limit = parseFloat($('#form_bathymetry__depth_max_input').val()) || 0;

                                const file = document.getElementById('form_bathymetry__data_input_file').files[0];
                                let reader = new FileReader();
                                reader.readAsText(file);
                                reader.onload = function () {
                                    sonar__bathymetryProcess(reader.result);
                                };
                                reader.onerror = function () {
                                    alert(reader.error);
                                };
                            }
                            function sonar__bathymetryProcess(dataTxt) {
                                const lines = dataTxt.split(/\n/);

                                for (const line of lines) {
                                    let pulses = [];
                                    let RR = [], FF = [];
                                    const raw = line.split(';');

                                    for (var i = 1; i <= 16; i++) {
                                        const mks = parseInt(raw[i]) || 0;
                                        if (mks > 0) {
                                            RR.push(mks);
                                        }
                                    }
                                    for (var i = 18; i <= 33; i++) {
                                        const mks = parseInt(raw[i]) || 0;
                                        if (mks > 0) {
                                            FF.push(mks);
                                        }
                                    }
                                    if (RR.length <= 0) {
                                        continue; //goto next line
                                    }

                                    //find widths of pulses and add to pulses-array
                                    for (const R of RR) {
                                        for (const F of FF) {
                                            if (R < F) {
                                                w_mks = F - R;
                                                const pulse = {
                                                    R: R,
                                                    F: F,
                                                    W: (F - R)
                                                };
                                                pulses.push(pulse);
                                                break;
                                            }
                                        }
                                    }

                                    let depth_mks = 0;
                                    for (const pulse of pulses) {
                                        const pulse_w_realBottom_mks_min = sonar__getPulse_w_realBottom_mks_min(pulse.R);
                                        if (pulse.W >= pulse_w_realBottom_mks_min) {
                                            depth_mks = pulse.R;
                                            break;
                                        }
                                    }

                                    //real point
                                    let lat = parseFloat(raw[34]) || 0;
                                    let lng = parseFloat(raw[35]) || 0;
                                    lat = Math.round(lat * 1000000) / 1000000;//6
                                    lng = Math.round(lng * 1000000) / 1000000;//6

                                    let depthM = depth_mks / sonar__mks2m;
                                    if (lat > 0 && lng > 0 && depthM >= sonar__depth_min_limit && depthM <= sonar__depth_max_limit) {

                                        //point real
                                        const idx = lat + '_' + lng;
                                        if (sonar__real_pointsLatLng.hasOwnProperty(idx)) {
                                            depthM = (sonar__real_pointsLatLng[idx].depthM + depthM) / 2.0;
                                            //pulses = pulses.concat(sonar__real_pointsLatLng[idx].pulses); //  Если складывать, то уплотняется картинка, хотя реально там такой плотности нет.
                                        }
                                        const point = {
                                            depthM: depthM,
                                            depth_mks: depth_mks,
                                            pulses: pulses
                                        };
                                        sonar__real_pointsLatLng[idx] = point;

                                        if (sonar__depth_min_m > depthM) {
                                            sonar__depth_min_m = depthM;
                                        }
                                        if (sonar__depth_max_m < depthM) {
                                            sonar__depth_max_m = depthM;
                                            sonar__depth_max_latlng = [lat, lng];
                                        }

                                        if (sonar__lat_min > lat) {
                                            sonar__lat_min = lat;
                                        }
                                        if (sonar__lng_min > lng) {
                                            sonar__lng_min = lng;
                                        }
                                        if (sonar__lat_max < lat) {
                                            sonar__lat_max = lat;
                                        }
                                        if (sonar__lng_max < lng) {
                                            sonar__lng_max = lng;
                                        }

                                        sonar__dataItemsCount++;
                                    }


                                } // one line

                                //all lines processed
                                $('#sonar__info_latMin').html(sonar__lat_min);
                                $('#sonar__info_latMax').html(sonar__lat_max);
                                $('#sonar__info_lngMin').html(sonar__lng_min);
                                $('#sonar__info_lngMax').html(sonar__lng_max);

                                $('#bathymetry__points_count').html(sonar__dataItemsCount + ' points');
                                $('#sonar__palette_depth_min_text').html(Math.round(sonar__depth_min_m * 100) / 100 + 'm');
                                $('#sonar__palette_depth_max_text').html(Math.round(sonar__depth_max_m * 100) / 100 + 'm ' + '<div class="d-inline-block" style=font-size:6px;>' + sonar__depth_max_latlng[0] + '<br>' + sonar__depth_max_latlng[1] + '</div>');

                                sonar__getColor_depth_m_dx = parseFloat(sonar__depth_max_m - sonar__depth_min_m) / (1.0 * sonar__colors_depth.length);
                                sonar__mks2px_fullScale_dx = (sonar__mks2px_fullScale_multiplier_vertical * sonar__depth_max_m * sonar__mks2m) / sonar__pulses_block_h_px;

                                sonar__resolution_calc();
                                sonar__axisDraw();

                                D3__pointsLatLng = sonar__real_pointsLatLng;
                            }
                            function sonar__getPulse_w_realBottom_mks_min(depth_mks) {
                                if (depth_mks < 2000) {
                                    return 1100;
                                }
                                if (depth_mks < 3000) {
                                    return 1200;
                                }
                                return 1200;
                            }
                            function sonar__pulses_hideWeak() {
                                const pulseW_mks = parseInt($('#sonar__range_pulse_w_min_show').val()) || 0;

                                $('div.sonar__plane_point_pulse').show().filter(function () {
                                    return $(this).attr('w_mks') < pulseW_mks;
                                }).hide();

                                $('div.sonar__section_pulse').show().filter(function () {
                                    return $(this).attr('w_mks') < pulseW_mks;
                                }).hide();

                                $('#sonar__range_pulse_w_min_show_val').html(pulseW_mks + 'mks');
                            }
                            function sonar__pulses_setColor() {
                                $('div.sonar__section_pulse').each(function () {
                                    const w_mks = parseInt($(this).attr('w_mks')) || 0;
                                    $(this).css('background-color', sonar__getColor_power_mks(w_mks));
                                });
                                $('div.sonar__plane_point_pulse').each(function () {
                                    const w_mks = parseInt($(this).attr('w_mks')) || 0;
                                    $(this).css('background-color', sonar__getColor_power_mks(w_mks));
                                });
                                if (sonar__palette_power_idx === 1 || sonar__palette_power_idx === 2) {
                                    $('div.sonar__section_pulse').css('opacity', 0.6);
                                } else {
                                    $('div.sonar__section_pulse').css('opacity', 1);
                                }
                            }

                            function sonar__resolution_calc() {
                                sonar__resolution_point_px = parseInt($('#sonar__resolution_point_px').val()) || 0;
                                sonar__resolution_dLat = parseFloat($('#sonar__resolution_dLat').val()) || 0;
                                sonar__resolution_dLng = parseFloat($('#sonar__resolution_dLng').val()) || 0;
                                sonar__pulse_size_offset_coef_lat = sonar__resolution_dLat / sonar__resolution_point_px;
                                sonar__pulse_size_offset_coef_lng = sonar__resolution_dLng / sonar__resolution_point_px;
                            }
                            function sonar__distanceTwoPoints_m(lat1, lng1, lat2, lng2) {
                                lat1 = lat1 * 0.01745329251994329576923690768489; //to rad PI/180
                                lat2 = lat2 * 0.01745329251994329576923690768489;
                                lng1 = lng1 * 0.01745329251994329576923690768489;
                                lng2 = lng2 * 0.01745329251994329576923690768489;
                                const x = (lng2 - lng1) * Math.cos((lat1 + lat2) / 2.0);
                                const y = (lat2 - lat1);
                                const d = Math.sqrt(x * x + y * y) * 6371.0;  //R = 6371km
                                return Math.round(d * 100000) / 100; // 1.86m
                            }
                            function sonar__axisDraw() {
                                $('div.sonar__axis').remove();
                                const lat_max_m = sonar__distanceTwoPoints_m(sonar__lat_min, parseFloat((sonar__lng_max - sonar__lng_min) / 2.0), sonar__lat_max, parseFloat((sonar__lng_max - sonar__lng_min) / 2.0));
                                const lng_max_m = sonar__distanceTwoPoints_m(parseFloat((sonar__lat_max - sonar__lat_min) / 2.0), sonar__lng_min, parseFloat((sonar__lat_max - sonar__lat_min) / 2.0), sonar__lng_max);
                                const lat_max_px = sonar__getOffsetLat_px(sonar__lat_min); //!sonar__lat_min 
                                const lng_max_px = sonar__getOffsetLng_px(sonar__lng_max);
                                const lat_10m_px = Math.round(10.0 * lat_max_px / lat_max_m);
                                const lng_10m_px = Math.round(10.0 * lng_max_px / lng_max_m);
                                const h_line = '<div style=" width:' + lng_10m_px + 'px; left:1px; top:1px; " class="sonar__axis" title="10m"></div>'; //lng=horis
                                const v_line = '<div style=" height:' + lat_10m_px + 'px; left:1px; top:1px; " class="sonar__axis" title="10m"></div>';//lat=vertical
                                $('#sonar__plane_block').append(h_line).append(v_line);
                                $('#sonar__section_block').append(h_line).append(v_line);
                            }


                            const sonar__componentToHex = c => {
                                const hex = c.toString(16);
                                return hex.length === 1 ? '0' + hex : hex;
                            };

                            const sonar__rgbToHex = (r, g, b) => '#' + [r, g, b].map(sonar__componentToHex).join('');


</script>












<style>  
    .sonar__axis{
        opacity: 0.8;
        background-color: black;       
        position: absolute;    
        padding: 0;
        margin: 0; 
        width: 2px;
        height: 2px;
    }
    #sonar__section_block{                
        overflow: scroll;
        position: relative;
        border: 1px solid #003580;  
        resize: both;
        min-height: 50px;
        min-width: 800px;         
    }
    #sonar__plane_block{          
        overflow: scroll;
        position: relative;
        border: 1px solid #003580; 
        min-width: 400px;
        min-height: 400px;
        resize: both;
    }
    #map__bathymetry_block{         
        overflow: scroll;
        position: relative;
        border: 1px solid #003580;         
        min-width: 400px;
        min-height: 400px;
        resize: both;
    }  

    .sonar__section_dotBottomDepth{        
        display: block;
        float: left;                
        position: absolute;                
        padding: 0;
        margin: 0;
        overflow: hidden;     
        z-index: 99999;
    }
    .sonar__section_pulse{     
        opacity: 0.6;
        background-color: black;       
        position: absolute;    
        padding: 0;
        margin: 0;              
    }  
    .sonar__section_dotBottomDepth_line{        
        display: block;
        float: left;        
        height: 16px;         
        position: absolute;                
        padding: 0;
        margin: 0;
        overflow: hidden;     
        z-index: 99999;
    }
    .sonar__section_area{ 
        background-color: red;
        position: absolute;    
        padding: 0;
        margin: 0; 
        z-index: 700;
    }

    .palette__item {
        width: 6px;
        height: 20px;
        margin: 0;
        padding: 0;
    }    

    .sonar__plane_point_pulses{
        display: block;
        float: left;                     
        position: absolute;        
        transform: rotate(45deg);
        transform-origin: bottom center;
        padding: 0;
        margin: 0;
        overflow: hidden;
        z-index: 1;
        z-index: 500;
    }
    .sonar__plane_point_pulses:hover{
        border-left: 1px solid red;
        border-right: 1px solid red;
        border-top: 1px solid red;        
        background-color: white;
        z-index: 500;      
    }
    .sonar__plane_point_pulse{     
        opacity: 0.3;
        background-color: black;       
        position: absolute;    
        padding: 0;
        margin: 0;
        height: 2px;
        z-index: 500;
    }        

    .sonar__plane_point_dot{        
        display: block;
        float: left;          
        position: absolute;
        opacity: 1;        
        padding: 0;
        margin: 0;  
        z-index: 600;
    }


</style>


<script>
    /* const D3__canvas_texture_palette = [
     '#ff3c00', '#fe4900', '#fe5600', '#fe6300', '#fd7000', '#fd7d00', '#fd8a00', '#fd9700', '#fca400', '#fcb100', '#fcbe00', '#fccb00', '#fbd800', '#fbe500', '#fbf200', '#fbff00',
     '#76ff00', '#6ef402', '#66ea04', '#5ee006', '#56d609', '#4ecc0b', '#46c20d', '#3eb80f', '#37ae12', '#2fa414', '#279a16', '#1f9018', '#17861b', '#0f7c1d', '#07721f', '#006822',
     '#3debff', '#3cdef7', '#3bd1ef', '#3ac4e8', '#39b7e0', '#39abd9', '#389ed1', '#3791ca', '#3684c2', '#3577bb', '#356bb3', '#345eac', '#3351a4', '#32449d', '#313795', '#312b8e'
     ];*/


    let D3__camera, D3__scene, D3__renderer;
    let D3__mesh, D3__texture, D3__geometry;
    let D3__controls;
    let D3__light;
    let D3__x_px = 256, D3__h_px = 256, D3__depth_px = 50;
    let D3__canvas_texture_getColor_count = 1024; //1024
    let D3__canvas_heightmap_getColor_dx, D3__canvas_texture_getColor_dx;
    let D3__canvas_offset_coef_lat, D3__canvas_offset_coef_lng;
    let D3__resolution_point_px;
    let D3__canvas_heightmap, D3__canvas_texture;

    document.addEventListener('DOMContentLoaded', function () {

    });

    function D3__canvases_draw() {
        D3__canvas_heightmap = document.getElementById('D3__canvas_heightmap');
        D3__canvas_heightmap.width = D3__x_px;
        D3__canvas_heightmap.height = D3__h_px;
        let D3__canvas_heightmap_ctx = D3__canvas_heightmap.getContext('2d');
        D3__canvas_heightmap_ctx.fillStyle = '#000000';
        D3__canvas_heightmap_ctx.fillRect(0, 0, D3__x_px, D3__h_px);

        D3__canvas_texture = document.getElementById('D3__canvas_texture');
        D3__canvas_texture.width = D3__x_px;
        D3__canvas_texture.height = D3__h_px;
        let D3__canvas_texture_ctx = D3__canvas_texture.getContext('2d');
        D3__canvas_texture_ctx.fillStyle = '#000000';
        D3__canvas_texture_ctx.fillRect(0, 0, D3__x_px, D3__h_px);

        //D3__canvas_heightmap.getContext('2d').filter = "blur(" + Math.round(D3__resolution_point_px/2) + "px)";
        //D3__canvas_texture.getContext('2d').filter = "blur(" + Math.round(D3__resolution_point_px/2) + "px)";                       

        for (let index in  D3__pointsLatLng) {
            const ll = index.split(/_/);
            const lat = parseFloat(ll[0]) || 0;
            const lng = parseFloat(ll[1]) || 0;
            const depthM = D3__pointsLatLng[index].depthM;
            const left_px = D3__canvas_getOffsetLng_px(lng);
            const top_px = D3__canvas_getOffsetLat_px(lat);

            D3__canvas_heightmap_ctx.fillStyle = D3__canvas_heightmap_getColor(depthM);
            D3__canvas_heightmap_ctx.fillRect(left_px, top_px, D3__resolution_point_px, D3__resolution_point_px); //(x, y, width, height)

            D3__canvas_texture_ctx.fillStyle = D3__canvas_texture_getColor(depthM);
            D3__canvas_texture_ctx.fillRect(left_px, top_px, D3__resolution_point_px, D3__resolution_point_px);
        }
    }
    function D3__canvas_heightmap_getColor(m) {
        let idx = Math.round((m - sonar__depth_min_m) / D3__canvas_heightmap_getColor_dx);
        idx = parseInt(255 - Math.min(Math.max(parseInt(idx), 0), 255)); //constrain from to                    
        return   sonar__rgbToHex(idx, idx, idx);
    }
    function D3__canvas_texture_getColor(m) {
        let idx = Math.round((m - sonar__depth_min_m) / D3__canvas_texture_getColor_dx);
        idx = parseInt(Math.min(Math.max(parseInt(idx), 0), D3__canvas_texture_getColor_count)); //constrain from to          
        return "hsl(" + (idx * (255 / D3__canvas_texture_getColor_count) % 360) + ",100%,50%)";

        /*let idx = Math.round((m - sonar__depth_min_m) / D3__canvas_texture_getColor_dx);
         idx = Math.min(Math.max(parseInt(idx), 0), (D3__canvas_texture_palette.length - 1)); //constrain from to
         return D3__canvas_texture_palette[idx];*/
    }
    function D3__canvas_getOffsetLat_px(lat) {
        let px = Math.round((sonar__lat_max - lat) / D3__canvas_offset_coef_lat);
        return px;
    }
    function D3__canvas_getOffsetLng_px(lng) {
        let px = Math.round((lng - sonar__lng_min) / D3__canvas_offset_coef_lng);
        return px;
    }

    function D3__init() {
        D3__resolution_point_px = parseInt($('#D3__resolution_point_px').val()) || 0;
        D3__canvas_heightmap_getColor_dx = parseFloat((sonar__depth_max_m - sonar__depth_min_m) / 255);
        D3__canvas_texture_getColor_dx = parseFloat((sonar__depth_max_m - sonar__depth_min_m) / D3__canvas_texture_getColor_count); //D3__canvas_texture_palette.length
        D3__canvas_offset_coef_lat = parseFloat(sonar__resolution_dLat / D3__resolution_point_px);
        D3__canvas_offset_coef_lng = parseFloat(sonar__resolution_dLng / D3__resolution_point_px);

        D3__x_px = parseInt(D3__canvas_getOffsetLng_px(sonar__lng_max));
        D3__h_px = parseInt(D3__canvas_getOffsetLat_px(sonar__lat_min));
        D3__depth_px = Math.round(Math.max(D3__x_px, D3__h_px) / 10.0);

        D3__canvases_draw();

        const container = document.getElementById('D3__container');
        container.innerHTML = '';

        THREE.Object3D.DefaultUp.set(0, 0, 1);// change axis to XY-Z (default is XZ-Y)

        //D3__camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 10000);
        D3__camera = new THREE.OrthographicCamera(D3__x_px / -2, D3__x_px / 2, D3__h_px / 2, D3__h_px / -2, 1, 10000);
        D3__camera.position.set(Math.round(D3__x_px / 2), Math.round(D3__h_px / 2), 200);

        D3__scene = new THREE.Scene();
        D3__scene.background = new THREE.Color('gray');
        //D3__scene.fog = new THREE.FogExp2(0xefd1b5, 0.0025);

        D3__renderer = new THREE.WebGLRenderer();
        D3__renderer.setPixelRatio(window.devicePixelRatio);
        D3__renderer.setSize(Math.round(1.6 * D3__x_px), Math.round(1.6 * D3__h_px));
        //D3__renderer.shadowMap.enabled = true;
        container.appendChild(D3__renderer.domElement);

        const canvasTexture = document.getElementById('D3__canvas_texture');
        D3__texture = new THREE.CanvasTexture(canvasTexture);
        //material = new THREE.MeshBasicMaterial({color: 0xffff00, side: THREE.DoubleSide});
        const D3__material = new THREE.MeshBasicMaterial({//MeshLambertMaterial // MeshBasicMaterial-doesnot have shadows\light
            map: D3__texture
        });

        D3__geometry = new THREE.PlaneGeometry(D3__x_px, D3__h_px, D3__x_px - 1, D3__h_px - 1);
        //D3__geometry.rotateX(-Math.PI / 2);
        //D3__geometry.rotateY(-Math.PI / 2);
        //

        const heightmap_data = D3__heightmap_getData();
        const vertices = D3__geometry.attributes.position.array;
        for (let i = 0, j = 4, l = vertices.length; i < l; i++, j += 3) {
            D3__geometry.attributes.position.array[j + 1] = Math.round(heightmap_data[i] * D3__depth_px / 765.0);  // R+g+b=255+255+255=765; 765=>D3__depth_px
        }


        D3__mesh = new THREE.Mesh(D3__geometry, D3__material);
        //D3__mesh.castShadow = true;
        //D3__mesh.receiveShadow = true;

        D3__mesh.material.smoothShading = true;
        D3__mesh.material.flatShading = true;
        D3__mesh.geometry.computeVertexNormals();


        D3__scene.add(D3__mesh);

        D3__controls = new OrbitControls(D3__camera, D3__renderer.domElement);
        D3__controls.addEventListener('change', render);
        D3__controls.target.set(0, 0, 0);
        //D3__controls.minDistance = 20;
        //D3__controls.maxDistance = 2500;
        D3__controls.enablePan = true;

        /*D3__light = new THREE.PointLight(0xffffff, 1, 100);
         D3__light.position.set(100, 100, 50);
         D3__light.castShadow = true; // default false
         D3__scene.add(D3__light);
         //Set up shadow properties for the light
         D3__light.shadow.mapSize.width = 512; // default
         D3__light.shadow.mapSize.height = 512; // default
         D3__light.shadow.camera.near = 0.5; // default
         D3__light.shadow.camera.far = 500; // default                     
         const helper = new THREE.CameraHelper(D3__light.shadow.camera);
         D3__scene.add(helper);*/
        /*D3__light = new THREE.DirectionalLight('0xFFFFFF', 0.75);
         D3__light.position.set(0, 0, 30);
         D3__light.target.position.set(0, 0, 0);
         D3__scene.add(D3__light);
         D3__scene.add(D3__light.target);                     
         let lightHelper = new THREE.DirectionalLightHelper(D3__light);
         D3__scene.add(lightHelper);                     
         let shadowCameraHelper = new THREE.CameraHelper(D3__light.shadow.camera);
         D3__scene.add(shadowCameraHelper);*/

        render();
        //animate();

        $("[D3__controls]").unbind('click');
        $("#D3__controls_x_dec").click(() => {
            D3__mesh.rotation.x -= 0.19;
            render();
        });
        $("#D3__controls_x_inc").click(() => {
            D3__mesh.rotation.x += 0.19;
            render();
        });
        $("#D3__controls_y_dec").click(() => {
            D3__mesh.rotation.y -= 0.19;
            render();
        });
        $("#D3__controls_y_inc").click(() => {
            D3__mesh.rotation.y += 0.19;
            render();
        });
        $("#D3__controls_z_dec").click(() => {
            D3__mesh.rotation.z -= 0.19;
            render();
        });
        $("#D3__controls_z_inc").click(() => {
            D3__mesh.rotation.z += 0.19;
            render();
        });

        $("#D3__controls_cam_dec").click(() => {
            D3__camera.position.z -= 10;
            render();
        });
        $("#D3__controls_cam_inc").click(() => {
            D3__camera.position.z += 10;
            render();
        });



    }


    function render() {
        D3__renderer.render(D3__scene, D3__camera);
    }


    function animate() {
        //requestAnimationFrame(animate);
        //D3__mesh.rotation.x += 0.005;
        //D3__mesh.rotation.y += 0.001;
        //D3__mesh.rotation.z += 0.01;
        //render();
    }



    function D3__heightmap_getData() {
        const D3__canvas_heightmap = document.getElementById('D3__canvas_heightmap');
        //const size = D3__x_px * D3__h_px;
        //let data = new Float32Array(size);
        /* for (let i = 0; i < size; i++) {
         data[i] = 0;
         }*/ //???
        const data = D3__canvas_heightmap.getContext('2d').getImageData(0, 0, D3__x_px, D3__h_px).data; //rgbargbargbargbargbargba
        var normPixels = [];
        for (var i = 0, n = data.length; i < n; i += 4) {
            normPixels.push((data[i] + data[i + 1] + data[i + 2])); //R, G and B
        }
        return normPixels;
    }


</script>